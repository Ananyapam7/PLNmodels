---
title: "PLNmodels: a case study"
subtitle: "The mollusk data set"
author: "PLN team"
date: "2019/01 (last update: `r Sys.Date()`)"
output:
  xaringan::moon_reader:
    chakra: libs/remark-latest.min.js
    css: ["pln.css", default, metropolis, metropolis-fonts]
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
---

```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)
```

class: inverse, center, middle

# Getting Started

---
# Requirements

## Package PLNmodels and dependencies

For this tutorial, you may preferably install the last release of **PLNmodels** from GitHub:

```{r install github, eval=FALSE, tidy=FALSE}
devtools::install_github("jchiquet/PLNmodels@v7.0.0")
```

Advanced users<sup>1</sup> can install the development version<sup>2</sup> from [Github](https://github.com/jchiquet/PLNmodels)

```{r install github2,  eval=FALSE, tidy=FALSE}
devtools::install_github('jchiquet/PLNmodels', build_vignettes = TRUE)
```

.footnote[
[1] Linux or Mac/Windows station equipped for building R packages
]
  
## Rstudio IDE

You are recommended to use the [RStudio IDE](https://www.rstudio.com/products/rstudio/).

- Create a new `R` Markdown document from the menu `File -> New File -> R Markdown`

- Click the `Knit` button to compile it or (best) use  Ctrl/⌘ + ⇧ + K

---

# First steps

## Loading the package

Check that the installation process succeeded

```{r loading package}
library(PLNmodels)
packageVersion("PLNmodels")
```

## Finding help and documentation

The [PLNmodels website](https://jchiquet.github.io/PLNmodels/) contains

- the standard package documentation 
- a set of comprehensive vignettes for the top-level functions

all formatted with [**pkgdown**](https://pkgdown.r-lib.org)

---

# Some additional useful packages

The tools provided by the two following libraries will be useful during our analyses.

```{r load tools}
library(tidyverse) # data manipulation
library(corrplot)  # plot of covariance/correlation matrices
```

---

class: inverse, center, middle

# The Mollusk data set

---

# Data overview

The `mollusk` variable is loaded by the function `data()`. 
```{r load mollusk}
data(mollusk)
```

It consists in a list of two data frames

```{r mollusk struct}
str(mollusk, max.level = 1)
```

These two data frames are typical from ecological data sets:

- The `abundance` table contains the counts of 32 species in 163 samples; 
- The `covariate` table contains information about 4  environmental variables.

Have a look at the help page with `?mollusk` to get additional details.

---

# Abundance table (I)

```{r glimpse Abundance}
mollusk$Abundance %>% 
  dplyr::select(1:10) %>% 
  head() %>% DT::datatable(fillContainer = FALSE)
```

---

# Abundance table (II)

```{r glance Abundances, fig.width=12, fig.height=4}
t(log(1 + mollusk$Abundance)) %>% 
  corrplot::corrplot(
    is.corr = FALSE,
    addgrid.col = NA, 
    tl.cex = .5, 
    cl.pos = "n"
  )
```

---

# Covariates

The three first covariates are categorical. The fourth one is numerical.

- `site`: sampling site
- `season`: winter, spring, summer, autumn
- `method`: sampling - wood or string
- `duration`: time of exposure (in week)

```{r covariates summary}
summary(mollusk$Covariate)
```

---

# Data preparation

In **PLNmodels**, data are handled into a single data frame that put together
1. the counts,
1. the potential covariates,
1. the offset that may be used in the models.

--

_Important!_
1. All the species found in the counts table will be used in the model,
2. The formula mechanism of `R` allow you to choose specific covariates or offsets.

--

The helping function `prepare_data` allows you to avoid taking care of cumbersome data manipulation <sup>1</sup>.

```{r prepare data, eval = FALSE}
prepare_data(
  counts     = , # your count table
  covariates = , # your covariates
  offset     = , # the method to compute offset
)
```

.footnote[
[1] variants of `prepare_data` exist for `biom` and `phyloseq` BioConductor formats.
]
---

# Preparing the mollusk data set 

We choose here to consider the total sum of count to build our vector of offsets

```{r preparing mollusc, warning = FALSE}
mollusc <- prepare_data(
    counts = mollusk$Abundance,
    covariates = mollusk$Covariate, 
{{   offset = "TSS" }} # look at other possible choices
  )
```

--

The structure of the final object is a data frame, but with some columns filled with matrices:

```{r structu mollusc}
str(mollusc, max.level = 1)
```

---

class: inverse, center, middle

# Multivariate Poisson Lognormal models with PLN

---

# The Poisson Lognormal model (PLN)

The PLN model is a multivariate generalized linear model, where 

- the counts $\mathbf{Y}_i$ are the response variables
- the main effect is due to a linear combination of the covariates $\mathbf{x}_i$
- a vector of offsets $\mathbf{o}_i$ can be specified for each sample.

$$
\mathbf{Y}_i | \mathbf{Z}_i \sim \mathcal{P}\left(\exp\{\mathbf{Z}_i\}\right), \qquad \mathbf{Z}_i \sim \mathcal{N}({\mathbf{o}_i + \mathbf{x}_i^\top\boldsymbol\Theta},\boldsymbol\Sigma), \\
$$
The unkwown parameters are 
- $\boldsymbol\Theta$, the matrix of regression parameters
- $\boldsymbol\Sigma$, the variance-covariance matrix

--

When all individuals $i=1,\dots,n$ are stacked together, the data matrices available to feed the model are

  - the $n\times p$ matrix of counts  $\mathbf{Y}$
  - the $n\times d$ matrix of design  $\mathbf{X}$
  - the $n\times p$ matrix of offsets $\mathbf{O}$

---

# The PLN function

The `PLN` function works in the same way as `lm`: 

```{r, eval = FALSE}
PLN(formula = , # mandatory
    data    = , # highly recommended
    subset    , # optional  
    weights   , # optional 
    control     # optional
  )
```

- `data` brings the variable to work with
- `formula` specifies how the relation between variables in `data`

  ( $\rightsquigarrow$ _It builds matrices_ $\mathbf{Y},\mathbf{X},\mathbf{O}$)

--

- `subset` is used for subsampling the observations, 
- `weights` is used to weighting the observations, 
- `control` is (mainly) used for tuning the optimization

---

# Simple PLN models on mollusc data (I)

The simplest model we can imagine only has an intercept term:

```{r mollusc PLN, cache = TRUE, results = FALSE}
M00_mollusc <- PLN(Abundance ~ 1, mollusc)
```

`M00_mollusc` is a particular `R` object that comes with a couple methods:

```{r mollusc PLN print}
M00_mollusc
```

---

# Accessing parameters: coefficients and co

```{r simple PLN coeff}
coef(M00_mollusc) %>% head() %>% t() %>% knitr::kable(format = "html")
```

```{r simple PLN others}
M00_mollusc$criteria %>% knitr::kable(format = "html")
```

Try some other fields!

---

# Accessing parameters: covariance

.pull-left[
```{r simple PLN covariance}
corrplot(
  vcov(M00_mollusc),
  is.corr = FALSE, tl.cex = .5
)
```
]

.pull-right[
```{r simple PLN correlation}
corrplot(
  cov2cor(vcov(M00_mollusc)),
  tl.cex = .5
)
```
]

---
# Playing with offsets

Let us try the Total sum of count for offset, and the sampling duration:

```{r simple PLN offsets, cache = TRUE, results = FALSE}
M01_mollusc <- PLN(Abundance ~ 1 + offset(log(Offset)) , mollusc)
M02_mollusc <- PLN(Abundance ~ 1 + offset(log(duration)), mollusc)
```

We then compare the models regarding their criteria:

```{r}
rbind(
  M00 = M00_mollusc$criteria,
  M01 = M01_mollusc$criteria, 
  M02 = M02_mollusc$criteria
) %>% knitr::kable(format = "html")
```

---

# Adding covariates: site effect (I)

The covariate `site` has 8 levels indicating the sampling site, 

```{r site table}
table(mollusc$site)
```

--

We would like to account for this covariate, as a natural candidate for explaining a part of the variance which is not very interesting regarding the interactions between species<sup>1</sup>:


```{r PLN covariate site, cache = TRUE, results = FALSE}
M11_mollusc <- PLN(Abundance ~ 0 + site + offset(log(Offset)), mollusc)
```

.footnote[
[1] Note the use of `0 + ` in the formula so that each parameters associated with the categorical variable corresponds to a mean effect in each modality. 
]

---
# Adding covariates: site effect (II)

There is a clear gain in introducing this covariate in the model:

```{r PLN covariate site results, echo = FALSE}
rbind(M01 = M01_mollusc$criteria, M11 = M11_mollusc$criteria) %>% knitr::kable(format = "html")
```

--

However, looking at the coefficients $\mathbf{\Theta}$ associated with `site`, some modalities may be regrouped, hoping for a gain in statistical power/efficiency:

```{r site matrix plot, fig.width=15, fig.height=5, echo = FALSE}
coef(M11_mollusc) %>% t() %>% corrplot(method = "color", is.corr = FALSE, tl.cex = 1, cl.pos = "n")
```

---

# Adding covariates (III)

So let us regroup the "Gravier" modalities and the "Negria" and adjust a model
```{r PLN regroup site modalities, cache = TRUE, results = FALSE}
mollusc <- mollusc %>% 
  mutate(site_new = 
    fct_collapse(site, 
      Gravier = c("GGravier1", "GGravier2", "GGravier3"),
      Negria  = c("Negria1", "Negria2")
    )
  )
M21_mollusc <- PLN(Abundance ~ 0 + site_new + offset(log(Offset)), mollusc)
```

--

There is a little loss in terms of loglikelihood, but the BIC choses the latter model:

```{r PLN covariate site regrouped results, echo = FALSE}
rbind(M11 = M11_mollusc$criteria, M21 = M21_mollusc$criteria) %>% knitr::kable(format = "html")
```


---

class: inverse, center, middle

# Dimension reduction and vizualisation with PLNPCA

---
# Poisson Lognormal model for Principal Component Analysis

The PLN-PCA model implemented in *PLNmodels* can viewed as a PLN model with an additional rank constraint on the covariance matrix $\boldsymbol\Sigma$ such that $\mathrm{rank}(\boldsymbol\Sigma)= q$:

$$\begin{array}{rcl}
  \text{latent space } &   \mathbf{Z}_i \sim \mathcal{N}(\mathbf{o}_i + \mathbf{x}_i^\top\boldsymbol\Theta,\boldsymbol\Sigma), & \boldsymbol\Sigma = \mathbf{B}\mathbf{B}^\top \\
  \text{observation space } &  Y_{ij} | Z_{ij} \quad \text{indep.} & Y_{ij} | Z_{ij} \sim \mathcal{P}\left(\exp\{Z_{ij}\}\right),
\end{array}$$

The dimension of the latent space $q$ corresponds to the number of axes in the PCA or, in other words, to the rank of $\boldsymbol\Sigma = \mathbf{B}\mathbf{B}^\intercal$.


The unkwown parameters are 
- $\boldsymbol\Theta$, the matrix of regression parameters
- $\mathbf{B}$, the matrix of _rescaled loadings_

---
# The PLNPCA function

The `PLNPCA` function works in the same way as `PLN`. 

There is just an additional parameter to control the successive value of the ranks to be considered:

```{r, eval = FALSE}
PLNPCA(formula = ,   # mandatory
       data    = ,   # highly recommended
       subset    ,   # optional  
       weights   ,   # optional 
*      ranks   = 1:5 # has default values
       control_init  # optional
       control_main  # optional
  )
```

- `ranks` is a vector of rank to be considered
- `control_init` is (mainly) used for tuning the initialization
- `control_main` is (mainly) used for tuning the optimization

The output will be a _collection_ of objects (or _family_), one per rank.

---
# A PCA analysis of the mollusc data set

Let us fit PLNPCA on our best model with offset:

```{r PLNPCA offset, cache = TRUE, results = FALSE}
PCA_offset <- PLNPCA(Abundance ~ 1 + offset(log(Offset)), mollusc, ranks = 1:8)
```

--

The ouput is a collection of `R` objects:

```{r print PLNPCA offset}
PCA_offset
```

This collection of object is itself an `R` object with a three methods: `plot`, `getModel`, `getBestModel`. (Additional help can be found with `?PLNPCAfamily`)

---
# PCA analysis: model selection (I)

The plot function gives you hints about the "right" rank for your data

```{r plot PLNPCA offset, fig.width = 12, fig.height=6}
plot(PCA_offset)
```

---
# PCA analysis: model selection (II)

To extract a particular model from the collection, use `getBestModel`:

```{r extract PLNPCA offset}
PCA_offset_BIC <- getBestModel(PCA_offset, "BIC")
```

--

The extracted object inherits from the `PLNfit` class (resulting from `PLN`), but with additional methods due to its `PCA` nature: when printing `PCA_offset_BIC`, we get

```{r print PLNPCAfit, echo = FALSE}
PCA_offset_BIC
```

---
# PCA analysis: model exploration

Inheritance allows you to rely on the same methods as with `PLN`:

.pull-left[
```{r PLN covariance M01}
corrplot(
  cov2cor(vcov(M01_mollusc)),
  tl.cex = .5
)
```
]

.pull-right[
```{r PLNPCA covariance}
corrplot(
  cov2cor(vcov(PCA_offset_BIC)),
  tl.cex = .5
)
```
]

---
# PCA: vizualisation 

The whole point of PCA is vizualisation via dimension reduction.

.pull-left[
```{r PCA offset vizu site, fig.width=6, fig.height=6, fig.align="center"}
plot(PCA_offset_BIC,
  ind_col = mollusc$site,
  nb_axes = 2)
```
]

.pull-right[
```{r PCA offset vizu site_new, fig.width=6, fig.height=6, fig.align="center"}
plot(PCA_offset_BIC, 
  ind_col = mollusc$site_new,
  nb_axes = 2)
```
]

---
# PCA: removing covariate effects

To hopefully fine more hidden effects in the data, we may wan to remove confounding ones:

```{r PCA covariate site, cache = TRUE, results = FALSE}
PCA_s <- PLNPCA(Abundance ~ 0 + site_new + offset(log(Offset)), mollusc, ranks = 1:8)
```

```{r PCA covariate site plot, echo = FALSE, fig.align="center", fig.width=6, fig.height=6}
plot(getBestModel(PCA_s, "BIC"), nb_axes = 2, ind_cols = mollusc$site_new)
```

---
# PCA: refinements in plotting (I)

```{r plot individual, fig.align = "center",  fig.height = 6.5, fig.width = 6.5}
plot(PCA_offset_BIC,  map = "individual", 
  ind_col = mollusc$site, main = "my individual map")
```

---

class: inverse, center, middle

# Discriminant Analysis for counts with PLNLDA

---

# Poisson Discriminant Analysis

In the vein of Fisher and Rao, we introduce a multi-class LDA model for multivariate count data which can viewed as a PLN model with a discrete group structure in the latent Gaussian space:

The PLN-LDA model assumes a discrete structure with $K$ groups in the following way: the different parameters ${\boldsymbol\mu}_k \in\mathbb{R}^p$ corresponds to the group-specific main effects and the variance matrix $\boldsymbol{\Sigma}$ is shared among groups:

$$\begin{array}{rcl}
  \text{latent space } &   \mathbf{Z}_i \sim \mathcal{N}(\mathbf{o}_i + \mathbf{x}_i^\top\boldsymbol\Theta + {\boldsymbol\mu}_i,\boldsymbol\Sigma) & \boldsymbol{\mu}_i = \mathbf{g}_i^\top \mathbf{M} \\
  \text{observation space } &  Y_{ij} | Z_{ij} \quad \text{indep.} & Y_{ij} | Z_{ij} \sim \mathcal{P}\left(\exp\{Z_{ij}\}\right),
\end{array}$$

where, $\mathbf{M} = [\boldsymbol{\mu}_1^\top, \dots, \boldsymbol{\mu}_K^\top]^\top$ is a $K \times p$ matrix collecting the group-specific main effects, and $\mathbf{g}_i$ is a group-indicator vector of length $K$ 

$$ g_{ik} = 1 \Leftrightarrow g_i = k $$

The unkwown parameters are 
- $\boldsymbol\Theta$, the matrix of regression parameters
- $\mathbf{M}$, the matrix containing the $K$ vectors of group means
- $\boldsymbol{\Sigma}$, the mvariance-covariance matrix

---
# The PLNLDA function

The `PLNLDA` function works in the same way as `PLN`. 

There is just an additional parameter to for the vector of groups on which the discriminant rule is built:

```{r, eval = FALSE}
PLNLDA(formula = , # mandatory
       data    = , # highly recommended
       subset    , # optional  
       weights   , # optional 
*      grouping  , # mandatory
       control     # optional
  )
```

- `grouping` is a factor of group () to be considered

---

# LDA of the mollusc data set: site (I)

Let us try a PLN-LDA on the `site_new` variable:

```{r PLNLDA site, cache = TRUE, results = FALSE}
LDA_site <- PLNLDA(
  Abundance ~ 1 + offset(log(Offset)), mollusc, 
    grouping = mollusc$site_new)
```

--

Contrary to PLNPCA, PLNLDA does not need no model selection, and has the same cost as a PLN fit. As usual, the printing method gives acces tho the availab fields and methods:

```{r LDA printing, echo = FALSE}
LDA_site
```

---
# LDA of the mollusc data set: site (II)

The plot function is useful to quickly view if some species separates well the groups:

```{r PLNLDA site plot, fig.align="center", fig.width = 6.5, fig.height = 6.5}
plot(LDA_site, nb_axes = 2)
```

---
# LDA of the mollusc data set: season

PLN-LDA works also very well for season, with or with correction of the `site effect`:

```{r PLNLDA season, results = FALSE, message = FALSE, warning = FALSE, cache = TRUE}
LDA_season1 <- PLNLDA(Abundance ~ 1 + offset(log(Offset)), 
  mollusc, grouping = mollusc$season)

LDA_season2 <- PLNLDA(Abundance ~ site_new + offset(log(Offset)), 
  mollusc, grouping = mollusc$season)
```

.pull-left[
```{r plot season1, echo = FALSE, fig.height = 6}
plot(LDA_season1, map = "individual", nb_axes = 1, main = "Without correction")
```
]

.pull-right[
```{r plot season2, echo = FALSE, fig.height = 6}
plot(LDA_season2, map = "individual", nb_axes = 1, main = "With correction")
```
]


---

class: center, middle, inverse

# Sparse structure estimation with PLNnetwork

---

# Sparse precision matrix for multivariate count

The PLN-network model for multivariate count data is a variant of PLN where we add a sparsity constraint on the inverse covariance matrix ${\boldsymbol\Sigma}^{-1}\triangleq \boldsymbol\Omega$ by means of the $\ell_1$-norm, such that $\|\boldsymbol\Omega\|_1 < c$:

$$\begin{array}{rcl}
  \text{latent space } &   \mathbf{Z}_i \sim \mathcal{N}\left({\mathbf{o}_i + \mathbf{x}_i^\top\boldsymbol\Theta},\boldsymbol\Omega^{-1}\right) &  \|\boldsymbol\Omega\|_1 < c \\
  \text{observation space } &  Y_{ij} | Z_{ij} \quad \text{indep.} & Y_{ij} | Z_{ij} \sim \mathcal{P}\left(\exp\{Z_{ij}\}\right)
  \end{array}$$

The $\ell_1$-penalty on $\boldsymbol\Omega$ induces sparsity and selection of important direct relationships between entities. Hence, the support of $\boldsymbol\Omega$ correspond to a network of underlying interactions. The sparsity level ($c$ in the above mathematical model), which corresponds to the number of edges in the network, is controlled by a penalty parameter in the optimization process sometimes referred to as $\lambda$.


---

# The PLNnetwork function

The `PLNnetwork` function works in the same way as `PLN`.

There is just an additional parameter to control the successive values of the sparsity contraint:

```{r, eval = FALSE}
PLNnetwork(formula = ,  # mandatory
           data    = ,  # highly recommended
           subset    ,  # optional  
           weights   ,  # optional 
*          penalties ,  # has default values
       control_init  # optional
       control_main  # optional
  )
```

- `penalties` is a vector controlling the successively applied sparsity constraints
- `control_init` is (mainly) used for tuning the initialization
- `control_main` is (mainly) used for tuning the optimization

--

$\rightsquigarrow$ The algorithm finds a penalty inducing an empty network and goes along the penalties levels, adding edges stepwisely.

---
# Controlling the range of visited networks

The range and size of the vector `penalties` may be controlled via `control_init`. For example,

```{r example, eval = FALSE}
my_control <- list(
  nPenalties = 40, # more penalties = more networks
  min.ratio = 1e-2 # the smaller, the denser the final network
)
PLNnetwork(formula, mydata,
* control_init = my_control
)
```

Be careful as 
- more network means more computation
- dense network means more computation, and less statistical significance !

---
# Network inference on the mollusc data set

We try inference of two collections of networks, with or without accounting for the site effect.

```{r PLNnetwork no site, cache = TRUE, results = FALSE}
networks_mollusc <- 
  PLNnetwork(
    Abundance ~ 1 + offset(log(Offset)),
    data = mollusc, 
    control_init = list(min.ratio = 1e-2)
  )
```

```{r PLNnetwork site, cache = TRUE, results = FALSE}
networks_mollusc_site <- 
  PLNnetwork(
    Abundance ~ 0 + site_new + offset(log(Offset)),
    data = mollusc, 
    control_init = list(min.ratio = 1e-2)
  )
```

---
# PLNnetwork: Model selection

Just like PLN-PCA, PLNnetwork produces a collection of models. The models are indexed by the sparsity level (or penalty). The plot function helps in choosing an appropriate level of penalty: 

.pull-left[
```{r plot network family, fig.width = 7, fig.height = 7, echo = FALSE, caption = "without correction"}
plot(networks_mollusc)
```
]

.pull-right[
```{r plot network family site, fig.width = 7, fig.height = 7, echo = FALSE, caption = "with site correction"}
plot(networks_mollusc_site)
```
]

---
# PLNnetwork: field access

Let us plot the residuals covariance matrices, after regularization of its inverse
.pull-left[
```{r plot covariance, fig.width = 7, fig.height = 7, caption = "without correction"}
net1 <- getBestModel(networks_mollusc)
corrplot(vcov(net1),
  cl.pos = "n", is.corr = FALSE)
```
]

.pull-right[
```{r plot network site, fig.width = 7, fig.height = 7, caption = "with site correction"}
net2 <- getBestModel(networks_mollusc_site)
corrplot(vcov(net2),
  cl.pos = "n", is.corr = FALSE)
```
]

---
# PLNnetwork: network specific functions 

**PLNmodels** brings additional plotting functions dedicated to network.

$\rightsquigarrow$ The `site` effect was masking the relevant interactions.

.pull-left[
```{r plot net, fig.width = 8, fig.height = 8, caption = "without correction"}
plot(net1)
```
]

.pull-right[
```{r plot net site, fig.width = 8, fig.height = 8, caption = "with site correction"}
plot(net2)
```
]

---
# PLNnetwork: stability selection

An alternative to model selection criteria is the stability selection  - or StARS in the context of network.

- Basically, it uses resampling to estimate robustness of each edges in the network.
- we keep the value of the penalty that guarantees a given level of robustness in the whole network

Careful: its is computationally expensive.

--

In `getBestModel`, when "StARS" is requested, stabiltiy selection is performed if needed:

```{r stability selection, cache = TRUE, eval = FALSE}
net3 <- getBestModel(networks_mollusc_site, "StARS") 
```



